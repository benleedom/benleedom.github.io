---
layout: post
title:  "Compiling Rebar: Introduction and Type Inference"
date:   2020-03-16 21:55:29 -0500
categories: jekyll update
---

# Introduction

[Rebar](https://github.com/rebarlang/rebar) is a graphical dataflow language with ownership, implemented as an addon to LabVIEW NXG. This post and others to follow will go in-depth on how the Rebar language is compiled, starting with semantic analysis in the front end and proceeding all the way to code generation.

The compiler for Rebar is similar in many ways to the compiler for many other programming languages, but the main differences have to do with its graphical nature and the interactive LabVIEW NXG environment. Compilers for text-based languages typically begin the compilation process for one or more language source files with a lexing and parsing stage, which means interpreting the characters in the source file as a stream of tokens, and then grouping the tokens into larger constructions like expressions and statements according to the grammar of the language. After this stage, the compiler can identify syntactic errors, like malformed identifiers (`0beginsWithNumber`, for instance) or expressions that don't fit the grammar (`1 + )`, for instance). If there are no errors, then the compiler keeps the result of the parse as an *abstract syntax tree*, a tree of nodes representing the different parts of the source, with each one identified by how it is described in the grammar. The rest of the compilation process can operate on this syntax tree.

The LabVIEW NXG environment, on the other hand, allows the user to create graphical diagrams containing nodes and wires interactively. The environment contains subsystems for *persisting* these diagrams to files, but this is separate from the compiler and the interactive editor; the editor operates on an in-memory representation of a diagram's structure called the *source model*, and the persistence subsystems are responsible for persisting the current state of the source model to disk. The source model contains enough details to reproduce all of the user's decisions when editing the diagram, such as the kind and position of each node, wire, and structure, the connections among them, and any edits the user has made to things like labels of constants or parameters. However, the compiler operates on a different representation of the diagram, for two reasons. First, the source model contains many details that are irrelevant to the compiler, like positioning--a node has the same meaning to the compiler if you move it twenty pixels to the right. Second, as we will see, the compiler needs to be able to make its own transformations to its representation of the diagram, but it does not want many of these transformations to appear to the user as changes to the source model. Thus, the first stage in the compiler for a document in the LabVIEW NXG environment is translating the source model of the document into a compiler-suitable representation, called *Data Flow Intermediate Representation* or DFIR. DFIR retains information about the kind of each node and structure and the wire connections among them.

Once the compiler has constructed the DFIR for a particular diagram, it begins to act more like a traditional compiler does. First, it analyzes the DFIR for semantic errors, and if any exist, it reports them back to the user (through the Errors and Warnings tool window) and stops compiling. If there are no semantic errors, it applies optimizations and other transforms to the DFIR to get it ready for code generation. Finally, it generates code for the diagram and caches the result; the generated code will eventually be combined with other compiled code and deployed to an execution target for running interactively, or packaged into a complete executable or binary library.

LabVIEW NXG compiles files individually and on-demand; it will typically request that a file be compiled after any user edit that results in semantic changes, like adding or removing a node or wire, but it may also request compilation in response to other events. The compiler is a complex subsystem of LabVIEW NXG, including various plugins that understand the semantics of each kind of document or the low-level of each kind of target, plus infrastructure that connects the compiler instances for multiple documents to each other in a massively parallel fashion. The Rebar Function compiler exists as one kind of plugin to all of this, waiting to be invoked by the rest of the framework to compile the latest version of a Function diagram.

# Rebar Function semantics in brief

